// delete是不会直接释放内存的，她只是间接的中断对象引用

// 赋值表达式从右向左执行

// 逗号操作符 对它的每个操作对象求值（从左至右），然后返回最后一个操作对象的值

// 当代码new f()执行时，下面事情将会发生：
// 一个新对象被创建。它继承自f.prototype
// 构造函数f被执行。执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例。new f等同于new f()，只能用在不传递任何参数的情况。
// 如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象

function _new(fn, ...args) {
    const obj = {};
    obj.__proto__ = fn.prototype;
    const result = fn.apply(obj, args)
    return result instanceof Object ? result : obj
}

// PUT方法
// 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有
// HEAD方法
// 只请求页面的首部
// OPTIONS方法
// 它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息
// TRACE方法
// TRACE方法被用于激发一个远程的，应用层的请求消息回路
// CONNECT方法
// 把请求连接转换到透明的TCP/IP通道

// 箭头函数：
// 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
// 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
// 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替
// 不可以使用yield命令，因此箭头函数不能用作Generator函数


// ES5的继承和ES6的继承有什么区别？
// ES5的继承时通过prototype或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。
// ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。
// 具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。
// ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。

// vue里面哪儿不会用到双向绑定 : 非UI控件不会涉及到数据双向绑定

// HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。
// 多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。
// HTTP2中
// 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。
// 单个连接上可以并行交错的请求和响应，之间互不干扰

// A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态?
// 非正常连接终止
// 三次握手完成后，在服务器accept前，客户发送RST(链接复位），会导致accpet出错，错误如何处理依赖于不同的实现:(
// 服务器和客户建立连接后，若服务器进程终止，则服务器发送FIN到客户。
// 服务器和客户建立连接后，若服务器主机崩溃，有两种可能：
// 服务器不重启，客户继续工作，就会发现对方没有回应(ETIMEOUT)，路由器聪明的话，则是目的地不可达(EHOSTUNREACH)。
// 服务器重启后，客户继续工作，然而服务器已丢失客户信息，收到客户数据后响应RST。
// 服务器和客户建立连接后，若服务器关机，init进程会给所有进程发送SIGTERM信号预警，然后发送SIGKILL关闭所有其他进程，这样和2情况没什么差别。

// 1) HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。
// 在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。
// 但是请记住 Request = Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。
// 首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。
// 同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输identity info（鉴别信息），来告诉服务端你是谁。
// 虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的处理时间，而且还会在网路传输中消耗过多的流量/时间。
// 但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。
// 同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了

// GUI渲染线程该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。

// 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调

// CMD (Common Module Definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。它主要特点是：对于依赖的模块是延迟执行，依赖可以就近书写，等到需要用这个依赖的时候再引入这个依赖，应用有sea.js.

// AMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js

// es6输出的是一个值的引用，es6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。es6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就生成 import/export
// common输出的是一个值的拷贝，模块可以多次加载，只会再第一次加载时运行一次，然后运行结果就被缓存了，以后再加载就直接读取缓存结果，因为加载的是一个对象，只有在脚本运行完才会生成 require('')

// cookies的特点：
// 每次的http请求头中，都会带有cookies——缺点；
// 每个域名只能存储4K大小的cookies;
// 主域名污染：如果我们使用cookies存储主域名的东西，那么子域名下得Http请求都会带上主域名的东西；

// 内存缓存（Memory Cache）是一个巨大的资源容器，渲染引擎（renderer）在渲染当前文档期间抓取的所有的资源都储存在其中，并且在文档生命周期内一直存在
// 但是Memory Cache是一个短期缓存，它只会在下一个导航前保存这些缓存，有些情况下可能更短。
// 但是Memory Cache不会轻易的命中一个请求，除了要有匹配的URL，还要有相同的资源类型、CORS模式以及一些其他特性。
// Memory Cache匹配规则在标准中没有详尽的描述，所以不同的浏览器内核在实现上会有所不同。
// Memory Cache是不关心HTTP语义的，比如Cache - Control: max - age=0的资源，仍然可以在同一个导航中被重用。但是在特定的情况下，
// Memory Cache会遵守Cache - Control: no - store指令，不缓存相应的资源。

// HTTP Cache也被叫做Disk Cache。
// 首先，HTTP Cache是持久化的，并且允许跨session甚至是跨站点地重用。如果一个资源被一个站点缓存在HTTP Cache中，另一个站点如果有相同的请求，是可以重用的。

// Push Cache是HTTP / 2推送的资源存储的地方。它是HTTP / 2会话的一部分。如果HTTP / 2会话关闭了，
// 储存在其中的资源都会消失。从不同的会话发起的请求将不会命中Push Cache中的资源。所有未被使用的资源在Push Cache会储存优先的时间（Chromium浏览器大约5分钟）。
// Push Cache根据请求的URL以及请求表头来匹配资源，但是不是严格遵守HTTP语义的
// 如果一个请求命中了Push Cache里的资源，那么这个资源将会从Push Cache里移除，然后经过HTTP Cache时，会保留一份拷贝缓存下来，
// 再经过Service Worker（如果有）时，也会保留一份拷贝储存下来，最后请求的资源回到渲染引擎时，Memory Cache会存储一份对该资源的引用，
// 如果将来本导航会话中的相同的资源请求，这份引用就可以直接被分配给该请求。

// Redux： view——> actions——> reducer——> state变化——> view变化（同步异步一样）
// Vuex： view——> commit——> mutations——> state变化——> view变化（同步操作） view——> dispatch——> actions——> mutations——> state变化——> view变化（异步操作）

// HTTPS与HTTP的一些区别
// HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
// HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL / TLS之上，SSL / TLS运行在TCP之上，所有传输的内容都经过加密的。
// HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。S
// HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

// HTTP2.0和HTTP1.X相比的新特性
// 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，
// 要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
// 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，
// 每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
// header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，
// 通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
// 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。

// 为什么需要头部压缩？
// 假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 
// 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 
// 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。

// HTTP2.0多路复用有多好？
// HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，
// 如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。
// HTTP / 2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。